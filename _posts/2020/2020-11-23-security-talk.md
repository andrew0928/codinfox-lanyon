---
layout: post
title: "[架構師觀點] 資安沒有捷徑，請從根本做起!"
categories:
- "系列文章: 架構師觀點"
tags: ["架構師", "資安"]
published: true
comments: true
redirect_from:
logo: /wp-content/images/2020-11-23-security-talk/2020-11-23-01-45-18.png
---

最近一連串資安事件，加上這兩天看到圈子內很熱門的討論串 (大意: 服務開發商，到底該不該儲存能還原的使用者密碼)，於是就想來寫點短篇一點的，說明一下我對軟體開發相關資安 issue 的看法。

![](/wp-content/images/2020-11-23-security-talk/2020-11-23-01-45-18.png)

> 那個討論串，我就不提供連結了。我的目的不是要把那位仁兄抓出來鞭，我只是要來聊聊這事件背後的看法而已。如果有人在底下留言附上 link, 我看到會刪掉的，先在此告知

其實我要談的，不是密碼該怎麼加密儲存 (encrypt)，或是只儲存加鹽後的雜湊 (salt + hash) 這些技術問題，我想探討的是技術決策或架構設計者的原則跟態度問題。在軟體開發團隊內 (尤其是技術決策者)，應該都要有正確的認知，不只是密碼儲存，而是泛指所有資安相關議題。如果你只把資安問題當作一種 "需求規格" 來看待，而非品質要求或是法規要求的話，那真的會讓公司陷入困境的。

<!--more-->

# 功能需求 vs 品質要求

其實不只資安問題，很多非功能需求其實都屬於品質要求這維度。例如效能，可靠度，擴充性等等。我用白話一點的例子來說明好了:


功能需求:

按照功能驗收，每一條測試案例都能順利通過，就算符合要求。
通常是正向表列，有列的測試案例就必須通過，你必須解決所有**已知**問題 (當然列表會隨時間一直追加 XDD)。


品質要求:

除了功能需求之外，必須通過各種壓力、攻擊、滲透等等測試，確保系統在這些極端條件下都還能順利運作，就算符合要求。
通常是負向表列，有列的案例都不能失敗，你必須解決所有**未知**問題 (列表也會一直增加無誤 XDD)。

品質需求比較困難的地方，一來較難測試驗證，二來就算發現了也不容易修改。到最後你都會發現，很多 "早知道" 當時怎麼設計就可以過關了...。品質問題，就是種典型沒有捷徑的問題，你只能老老實實地從根本做起才能預防。

回到文章最前面，一開始就破題的 "儲存密碼" 問題。不能儲存密碼，這其實就是個品質要求，而不是功能要求。這要求的背後，目的是希望你的服務即使被外人破解或是竊取資料庫，只要不儲存密碼，小偷就沒有辦法把你的客戶密碼都拿走。這些 "保證"，不是來自規格上有這條，而你也照做換來的，是你開發過程在設計 "設定密碼" 時就做好正確的決策，不儲存密碼，改為 +salt 來計算 hash 替代。過程麻煩了一點，但是整個設計就完全讓你沒有可能還原密碼，自然也可以完全保證密碼不會因為你的資料庫而外洩。




# 資安，是信任問題，你必須做 "對的事" 才能換來信任

如同前面的例子，資安類型的問題，都是要求你在某些關鍵資訊的處理一定要到位 (例如密碼、信用卡卡號、交易、個資等等)，讓其他人完全相信你不會有意或無意，破壞客戶的安全。

例如: 只要系統不儲存密碼，就可以免除各種資料庫外洩造成的密碼外洩。

例如: 只要客戶有妥善保管好自己的金鑰，並且用它來進行交易，那麼就可以杜絕別人假冒你的名義進行交易。

例如: 只要你有妥善保管好自己的金鑰，那麼發不出去的資訊只要附上數位簽章，就可以杜絕別人假冒你的名義發布資訊。

例如: 只要雙方都妥善保管好自己的金鑰，雙方就可以在不安全的環境下 (如 internet)，安全的交換資料。

這些保證，其實都來自於你把最關鍵的地方，用公認安全的演算法來進行處理，得到的結果。需要受到保護的資訊，只要在儲存時做好加密處理，那麼任何地方需要使用這些資訊時，加密演算法替你保證了 "沒有金鑰就無法使用資訊" 這件事。比起你做了 100 項測試，證明這些操作都無法取得機敏資訊，還不如直接給客戶看你的資料庫，機敏資訊都被妥善的加密過來的可靠。


這裡，帶出了兩件事:

1. 該加密就要加密。不用公開的加密演算法，你自己土炮的各種方法通常都不夠安全，很容易被破解的。
1. 你挑選了合適的演算法跟金鑰長度，數學就替你保證了在當今的計算能力下，有限的時間內無法破解。

這兩件事，其實就是信任的來源。你可以在任何地方做最佳化，但是千萬別在這些安全的程序上省略，否則會得不嘗失的。也許你會覺得奇怪，我如果用我自己設計的加密方式，你根本猜不到啊，怎麼會不安全?

我舉幾個案例你就知道了:

1. 統計學:  
假設你用了很瞎的字元對照表，把資料重新 mapping 成新的樣子，期待不知道 mapping 的人就解不回來...。其實這不大安全的，有人就這樣破解過，先拿其他資料當作樣本來分析，例如分析一本小說，所有出現的字母， "S" 出現的比率最高，那麼你的土炮加密法出現比率最高的那個字，可能就是 "S" .. 依此類推，可能就被破解了而不自知。(有看過電影: 模仿遊戲嗎? 很有意思的電影，值得看一看)

2. Code Repository:  
在現代的軟體工程裡面，存放 source code 都不夠安全的。程式碼都強調可讀性高，好維護等等特性，目的就是你寫的 code 就是要讓別人好維護啊! 那代表你的 code 就是有別人會看的到，土炮加密演算法通常都是仗著別人不曉得你怎麼加密來保護的；相對於公開安全的演算法，這些演算法都把加解密的過程公開，程式碼也公開。安全性則是來自你必須保護好的金鑰。演算法背後的數學已經證明了你必須持有金鑰才能取得正確資訊，而非程式碼。

剩下的，還是那句話: 該加密就要加密，挑選合適的演算法 + 金鑰長度，你的系統就能讓別人有基本的信任。

由於資安 / 品質問題，往往都被認為是吃力不討好的那一方，做的好別人看不到 (短時間)，卻多花了很多資源在上面。因此在時程緊迫的時候往往最容易被犧牲掉。最容易看到這種狀況，通常都是一次性的專案外包...。而願意好好投資在品質身上的，往往都是自己開發自己使用的產品或服務居多，或是標準化大量使用的軟體，有投資在品質的價值的系統。所以，當我看了最前面提到的那討論串，自己的服務不好好顧，還放任團隊設計出會儲存密碼的系統，真的是把自己的信譽當玩笑啊... 要事讓我發現了一次，我絕對不會再去用那套系統 (即使事後官方宣稱已經改善，因為我覺得那是團隊文化問題)。


# 其他案例: session

除了密碼，或是個資加密之外，這類例子還有很多啊! 隨便舉都是一堆。以我最近碰到的案子為例，登入 session 的處理也是 (尤其是分散式跨服務的情況)。所謂的 session, 就是當你在登入時通過驗證 (ex: 帳號密碼 + 二階段驗證) 後，直到你登出之前，系統都會認得你，不需要不斷地進行驗證，這就是指 session。

不好處理的地方在於分散式。你經過 A service 驗證，如何讓 B service 承認你的 session ? 當然 create 一把 token 帶過去，B 擔心的話就打 API 問問 A 就可以了。不過往返的通訊成本很高啊，因此業界發展出類似 JWT 這樣標準化的機制，善用加密或是簽章的演算法，你可以省去大部分的通訊，只剩下計算，就能保有一定的安全性。

不過，即使用了 JWT, 你也是有些成本要花費啊! 不論是用現成的框架，或是自己寫，你每個 request 都該做好基本的 token validation (驗證簽章，確認 token 是否被破壞過) 啊! token 驗證無誤，你才能相信裡面夾帶的資訊，包含 expire time, user id 等等資訊，做到不用跟對方通訊就能信任 token 的內容。

我常常舉火車站驗票的機制當例子啊! 在票證還沒電子化之前，車掌驗票時可沒辦法每張票都打電話跟售票員確認真偽，這時靠的就是小小一張車票本身的各種防偽設計。例如特殊的紙質，編碼規則，甚至是蓋章等等，總之能夠讓車掌當下就能判定即可。確認票是真的，剩下就只要再核對上面的車次跟座位是否符合就可以了。

這邊也是一樣，基礎是省不了的啊! 例如每個 request 做好基本的驗證就是必須的，你也許會覺得這樣要花掉很多加解密的運算，很吃 CPU ...，但是我只能說這是必要的，你當然可以省掉，只是省掉的地方就是你系統的潛在風險的所在了。



# 其他案例: 授權

其實權限管理，也是一個常見的大地雷...。所謂大地雷，就是開發人員很容易就自己刻一套安全機制，結果就在不經意的地方，把不該輸出的資料給傳出去了。

舉個常見的例子: 如果按照規則，我的帳號只能看到我部門的員工資訊，結果 100 個功能有一個漏掉忘了檢查，在這個功能就把其他 99 個功能都擋下來的資訊給洩漏出去了。這一個漏洞就會變成老鼠屎，讓整個系統的安全性不合格。

很多網站的安全性，只做在 UI 或是選單，讓使用者點不到就了事了，就是屬於這種狀況。還有一種常見的例子就是，權限檢查只做在第一頁，網站的超連結，很容易點來點去，你就忘了你是從哪邊進來的。有的情況則是兩三個不同的功能入口，會點進同一頁，結果一個入口給你授權，另一個入口不給，那你到這頁共用的頁面，到底能不能看到機密資訊?

有共用資源的都很容易踩到這個坑，把共用頁面換成共用 API，結果也是一樣。這種狀況該怎麼避免? 還是一樣，沒有捷徑，你只能老老實實的做好安全機制。

第一關是老老實實的設計好你的 "安全機制"。你如果不去定義全域的安全規則，把這責任丟給每個功能自己設計，你就很容易踩到矛盾狀況。比如 A 功能讓你看員工資料，B 功能卻禁止，這是系統設計允許使用者設定出不合理的權限造成的。這時你要說他是個 bug 嗎? 有點難，因為你已經騎虎難下了，有問題的是規格，不是實作啊!

老實的做法，其實也很簡單，別依賴每個功能自己決定授權的機制，你應該整個服務，至少整個模組 (比如部門出缺勤管理)，定義一個通用的規範 (例如: 部門主管只能看到自己部門的員工請假狀況)。該模組所有功能，不論你從哪裡點進來，都該 follow 這規則，你才能避免前面講的狀況。

實作方面，就是工程問題了，相對好了解一點。首先控制好資料進出的關卡 (例如 API)，越小的接觸面積，越好防護，盡可能的收斂暴露資料的管道。接著，統一識別身分的方式，例如用前面段落提到的 session token 就是個好方法。如果 session token 能在登入時確定你的部門跟身分 (是否為主管)，那麼其他 API 只要在傳回資料時比對好 session token 的身分，是否符合傳回資料的要求就可以了。


# 結論: 沒有捷徑，老老實實的實作才是上策

零零總總，舉了幾個跟資安相關的案例，沒有扯到太深的技術，也沒有貼到 source code .. 單純看到 facebook 上面的討論串有感而發，寫了這篇。系統的設計很多地方真的都是省不得的啊! 你也許以為你賺到了，其實那只是暫時的，往後會付出代價的。盡可能別標新立異，盡量套用設計良好的框架來處理安全問題吧! 如果真的有必要自己打造，那請至少用公認標準的 patterns 來設計。

越是安全類的，或是品質、架構類的問題，結論都一樣! 沒有捷徑的，好好的充實自己的經驗能力，老老實實一步一步的實作才是上策啊!
