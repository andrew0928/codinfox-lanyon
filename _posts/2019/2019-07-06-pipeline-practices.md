---
layout: post
title: "後端工程師必備: "
categories:
tags: ["系列文章", "架構師", "CLI", "C#", "PIPELINE", "串流處理", "TIPS"]
published: true
comments: true
redirect_from:
logo: 
---

這篇換個方式，來聊聊後端工程師的基本功夫吧。我在公司負責架構的團隊，我出了個練習題，目的是測驗大家對於處理大量複雜的任務的精準程度。這篇文章，我想換個方式來進行，我把這練習題的 source code 公開出來，有興趣的朋友可以練習看看。如果你願意將你的 solution PR 放上來，我就在下一篇文章內幫你 code review 當作回報。之前會想在內部讓 team member 做這練習，目的很簡單，現在的工程師越來越容易忽略掉一些開發的基礎能力，因為有太多框架或是服務可以使用，開發上過度簡化，就會讓 developer 有種成本降低的錯覺 (降低的只有開發成本)。如果對等的效能沒有等比下降，費用會反映在運算成本上啊! 這情況在你的流量很大的時候，加上背後的運算資源都來自雲端服務時會更明顯...。

因此，這練習的目的，我都會在一對一面談的時候，問問 developer 自己是否想過這些問題:

1. 你是否能很 **精準** 的掌控你寫出來的 code ? 
1. 你是否清楚了解你面對的問題 **理想** 的效能在哪裡? 
1. 針對效能這件事，你是否有明確的 **指標** 來量化及評斷每個 solution 的好壞? 
1. 你的解法離 **理想** 情況還有多遠? 是否還有改善空間? 還是已經到理論極限了? 

後端工程師免不了必須解決很多效能及穩定度的問題，因此 "精準" 的掌握你程式碼在做啥事，我覺得是很關鍵的一點。商業邏輯我想你寫得出來大概都沒問題，但是每當我講到平行處理 (例如非同步、多執行續、或是 scale out) 等等議題時，我發現能清楚掌握的人就少了一大半了。如果討論我們多執行緒應該怎麼安排這些任務的處理規則，能精準地寫出來的人又少了一大半...。

練習的題目很簡單，我設計了一個 class library project, 函式庫內我定義了一個類別 MyTask，他的 instance 必須按照順序呼叫 DoStep1(), DoStep2(), DoStep3() 才算完成。練習的題目就是: 你必須處理完 1000 個 MyTask 物件才算完成任務。處理過程中有些限制需要克服:

1. 每個 task instance 的 Step 必須按照順序進行。
1. 每個 Step 的平行處理數量是有上限的。
1. 不同的 Step 執行時需要花費的時間不同。
1. 每個 task instance, 每個 step 執行過程都需要 allocate 不同的 memory。

會定義這些規則，目的就是希望 developer 在解題的過程中，必須知道你用的方式會花費多少資源? 例如 (4), 你就不能無限制地開啟任意數量的 threads 來處理... 受限於 (1), 你只會得到有限的效能提升，可是你卻得花費過多的 memory ...

題目會用 IEnumerable<MyTask> 的方式交付 1000 個物件，你的目標是寫一個 Runner 接到 Task, 把它消化完畢就對了。不限定你用任何方式或是框架來處理。不過，我會看這幾個指標來判定你做出來的品質:

1. 主要目標:   是否有確實完成每個 Task? 每個 Task 都必須按照順序完成每個 Step。
1. 品質指標 1: 過程中最大的 WIP (WIP: Work In Progress, 半成品, 只要開始 step1 而未完成的 task 都算) 數量。
1. 品質指標 2: 過程中占用的 memory size 最大值 (max memory allocated)。
1. 品質指標 3: 程式啟動後，第一個 task 完成所需要花費的時間 (TTFT, time to first task)。
1. 品質指標 4: 所有 Task 處理完畢的時間。

準備好接受挑戰了嗎? 現在就去下載題目來試著解看看吧! 這篇文章我會分成前後兩段來發布。前半先發布題目，如果你有意願的話，在一個月內 (時間 FB 我會說明)，在 GitHub 把你的 Runner 發 Pull Request 給我, 我會在後半段發布的內放上 PR 給我的 code, 並且評論一下每種解法的優缺點。

<!--more-->

# 寫在前面: 動機

會寫這文章的動機很單純，就是我一直覺的很多後端工程師必備的基本功，在這個框架滿天飛的年代，都被忽略了。很多問題明明只要基本知識足夠，簡單兩下就能搞定，但是越來越多工程師抱著大部頭的框架來解決。解了問題是好事，但是也讓後續的維護門檻變困難，長期下來得不嘗失啊!

這類問題，平常在做 code review 很難深入到這樣的問題啊 (要是真正趕時間的專案，被我用這樣的標準來 code review, 大概整段 code 都會被我翻掉)，在動手寫 code 之前就先做好充分練習才是根本之道，因此我就出了這樣的練習題給 team member 試看看，發現效果還不錯，於是就擴大範圍，也讓其他有興趣的朋友們參與看看。

當然我還有另一個動機: 招募。我也希望能藉這機會找到有心想磨練自己基本功的工程師，這樣的 code 交流我相信比面試聊上一個小時精準的多了。最重要的是透過這樣的方式，你會更清楚知道團隊的要求，你也可以藉這機會試試自己能力；加入團隊後會有更多這樣的挑戰與應用的機會。這不見得是件輕鬆的事情，但是如果你有興趣，這絕對是個難得的機會。


# 題目規則說明

如果你想試看看這個練習題，規則很簡單... 題目的 source code 我放在我的 GitHub Repo, 有興趣的人自己拿回去看就好。如果你願意 PR 給我你的 code, 請按照最後面的規則說明。截止期限到我下一篇文章出來之前為止都可以，預估大約一個月左右吧 ( ~ 2019/09/16 )。

題目很簡單，我都封裝在一個 .NET core 的 class library project 內了。你只要 create console app, 繼承我準備的 TaskRunnerBase, 寫一個你自己版本的 TaskRunner, 然後在 Main 裡面啟動他就可以了。

隨題目我附上一個很無腦的 demo, 請參考 AndrewDemo 這個 console app project, 就是用 for loop 把每個 task 的 DoTaskN() 從 1 ~ 3 分別執行一次而已，完全沒有平行處理也沒有最佳化，各位就當作押隊的吧，理論上你應該不會寫出比這個 demo 還慢的版本...

規則很簡單，第一，先準備一個你的 TaskRunner:

```csharp

public class AndrewTaskRunner0 : TaskRunnerBase
{
    public override void Run(IEnumerable<MyTask> tasks)
    {
        foreach (var task in tasks)
        {
            task.DoStepN(1);
            task.DoStepN(2);
            task.DoStepN(3);
        }
    }
}

```

然後，在 Main() 內這樣啟動你的 Runner 就夠了:


```csharp

class Program
{
    static void Main(string[] args)
    {
        TaskRunnerBase run = new AndrewTaskRunner0();
        run.ExecuteTasks(100);
    }

}

```    

執行完畢之後，會有兩個地方可以看到執行結果。第一個是 console output:

```logs

Execution Summary: AndrewDemo.AndrewTaskRunner0, PASS

* Max WIP:
  - ALL:      1
  - Step #1:  1
  - Step #2:  1
  - Step #3:  1

* Used Resources:
  - Memory Usage (Peak):  1536
  - Context Switch Count: 300

* Waiting (Lead) Time:
  - Time To First Task Completed: 1443.1671 msec
  - Time To Last Task Completed:  143032.4147 msec
  - Total Waiting Time: 7223482.8365 / msec, Average Waiting Time: 72234.828365

* Execute Count:
  - Total:   100
  - Success: 100
  - Failure: 0
  - Complete Step #1: 100
  - Complete Step #2: 100
  - Complete Step #3: 100

C:\Program Files\dotnet\dotnet.exe (process 6368) exited with code 0.
Press any key to close this window . . .

```


第二個，會在執行檔同樣目錄下產生一個 .csv (後面會說明), 裡面會有執行過程中不斷記錄下來的幾個關鍵指標:

```csv

TS,MEM,WIP_ALL,WIP1,WIP2,WIP3,THREADS_COUNT,ENTER1,ENTER2,ENTER3,EXIT1,EXIT2,EXIT3,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30
8,0,0,0,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
32,1536,1,1,0,0,1,1,0,0,0,0,0,1#1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
60,1536,1,1,0,0,1,1,0,0,0,0,0,1#1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
90,1536,1,1,0,0,1,1,0,0,0,0,0,1#1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
120,1536,1,1,0,0,1,1,0,0,0,0,0,1#1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
150,1536,1,1,0,0,1,1,0,0,0,0,0,1#1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
180,1536,1,1,0,0,1,1,0,0,0,0,0,1#1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
210,1536,1,1,0,0,1,1,0,0,0,0,0,1#1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
240,1536,1,1,0,0,1,1,0,0,0,0,0,1#1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
(以下略)

```

這個 csv 是方便你用 excel 打開，直接用圖表來將你的執行成效視覺化用的。舉例來說，前兩個欄位 TS (time stamp, msec) 跟 MEM (allocated memory, bytes) 我把它用 excel 繪製成圖表的話，可以看到這樣的 chart:

![](/wp-content\images\2019-07-06-pipeline-practices/021612.png)



不過，這個版本的 code 實在太單調了，完全看不出啥效果... 我換一個我自己測是 thread pool 的版本。先來看記憶體使用量:

![](021935.png)


其實 .csv 內還藏了不少數據, 另外有一組是 WIP1 ~ WIP3, WIP_ALL, 分別代表在 Step1 ~ Step3, 以及所有未完成的 task(s) 總數:

![](022611.png)


這段程式碼，我用了 thread pool 的技巧來平行處理, THREADS_COUNT 欄位可以看到過程中同時有多少個 threads 並行:

![](022835.png)


最後，來看一個特別的；這不是看圖表了，直接看表格的內容:

![](023121.png)

TS 代表程式開始執行的時間 (單位: msec), T1 ~ T30 則代表我最多會顯示每個時間點，每個 thread 都在做啥事，T1 代表第一個 thread, T2 代表第二個，以此類推。至於表格內的數字，如 ```14#1```, 則代表 ```第 14 個 task 的第一個步驟```，我加上了框線，讓大家看得清楚一點，從上到下，可以看到你的 task 是如何被分配到每個 threads 執行的。你會發現，因為平行運算被受到限制，並不是每個 threads 都隨時保持忙碌的，中間空白的部分代表這個 thread 正在發呆，沒有任務可以進行。

到目前為止，這些資訊都是為了讓你 **精準** 的了解你的 code 到底是怎麼跑的，對於效能好壞也有個明確的指標可以評估。至於這些指標都代表什麼意義，請繼續看下面的說明。



















# 品質指標的挑選

要通過這個測驗，其實很簡單，寫個 for loop 就搞定了，但是要比較出好壞，那就要花點心思。我這邊說明一下為何我要挑選這幾個指標來評斷 code 的優劣。這些指標，其實都可以對應到各位日常碰到的實際案例，我就一一來說明。

開始之前，先來看一下最陽春的 runner (實際開發方式請參考後面的說明):

```csharp

public class AndrewTaskRunner : TaskRunnerBase
{
    public override void Run(IEnumerable<MyTask> tasks)
    {
        foreach (var task in tasks)
        {
            task.DoStepN(1);
            task.DoStepN(2);
            task.DoStepN(3);
        }
    }
}

```

這 solution 相當簡單易懂，也沒有任何最佳化... 就是按照順序，把每個 (預設 1000 個) MyTask instance 的 DoStepN(1) ~ DoStepN(3) 照順序執行過一次，就算完成。這是絕對正確的 solution, 但是完全沒有任何最佳化, 成績也不會太好看，就當作對照組來來說明。

以這個對照組當作案例，來看看下列各個指標的定義，與背後代表的意義為何吧!


## 指標: 最大半成品數

這裡指的 "半成品" (WIP, Work In Progress) 數, 就是指同一瞬間，有多少 Task 是處於 DoStepN(1) 已經開始，而 DoStepN(3) 還沒完全結束的階段。

為何我會拿 WIP 當作指標? 對應到現實世界的 Task, 通常啟動後就會占用一些資源，從 temp file, memory cahce, memory buffer, 甚至是為了處理任務過程中需要的 temp object 等等都算。如果你用了各種平行處理的技巧來加速，別忘了 WIP 越高，過程中你需要佔用的資源越多，這些資源要在 DoStepN(3) 結束後才會被釋放，你必須在平行處理與 WIP 數量之間取得平衡。

WIP 過高，先不論對效能的影響，如果對於關鍵資源 (如 memory) 敏感一點的環境, 也許你的系統撐不過尖峰就會掛掉了。因此這次的題目，會監控 Runner 全程執行過程中，WIP 的最大值，當作 max(WIP) 指標。


## 指標: 第一個任務完成時間

熟悉 SCRUM 的大概都對 WIP 不陌生，這名詞我的卻是從那邊借來用的。另一個 SCRUM 在做任務管理的指標就是 Lead Time (交期, 從需求提供到任務完成交付的時間)。這邊我也拿 Lead Time 當作指標之一。不過我比較偏好 TTFT (Time To First Task completed) 這名詞。這名詞我是從 Browser 的開發工具那邊學來的用法。監控網頁下載效率，有個很重要的指標 TTFB (Time To First Byte) 也是一樣的意思。

TTFT 會直接影響使用者的感受，有大量 Task 交付執行時，你能完成第一個的時間，就是使用者視角看到的 Lead Time。過去在念作業系統 (OS, Operation System) 時, 對於多工排程的機制也有類似的指標，那個叫 "平均等待時間"，意思是每個 Task 從被交付到 OS 開始 (這裡指的是 Runner 啟動) 到 Task 完成的時間平均。TTFT 越大，代表你花越多時間在 "等待" 某些階段的完成。

如果你能越早交付第一個 Task, 使用者就會感受到系統的回應速度越快，如果使用者端能配合，或許有後續的任務就能越快啟動。這是我挑選這個指標的用意。



## 指標: 所有任務完成時間

相較於 TTFT 在意第一個 Task 完成的時間，另一個代表整體效能的指標則是整體完成時間，如果你硬要對照的話，可以把它看成 TTLT (Time To Last Task completed) 也行。這指標完全不管過程中你如何交付 Task 的，只看最後一筆的交付時間，這指標代表整體效率。

有些情況下，TTFT / TTLT 哪個重要，其實很難斷定，完全看你對於系統的服務品質怎麼定義。舉例來說，當 Task 的數量很大的時候，你能否忍受一個明明只要一秒鐘就能完成的任務，卻要在 1 小時後才能得到結果，換來的代價可能是整體完成的時間可以加速 30%, 或是執行的成本降低 30% ? 不同的考量，會影響這些指標的重要程度。

我在這個案例，由於我考量的是 pipeline, 越快完成第一個任務，我後續的階段就能越快開始，因此我把 TTFT 的重要性排在前面。




## 指標: 平均完成時間

這是從 OS 排程那邊學來的另一個指標。只看第一個任務，跟只看最後一個任務的完成時間，其實都是兩個極端。老實說我要是知道規則還蠻容易作弊的 XDDD, 假設我整批處理能縮短 30% 的執行時間，那麼為了 KPI 好看，我可以只處理第一筆，然後就交付成績；後面 2 ~ N 筆再用最有效率的做法，再最後才一次交付 2 ~ N 筆 Task 的成果，來衝這兩個 KPI 帳面上的數字...

當然這樣就本末倒置了，使用者體驗一定是不好的啊，因此我追加一個 OS 提到的指標: 平均等待時間。

這指標的定義是:每個 Task 的交期的平均值。這個案例裡，就是每個 Task 從 Runner 啟動開始，到 DoStepN(3) 完成為止的時間總平均。這是介於 TTFT 與 TTLT 中間的指標，越低代表使用者需要等待 (就是 Lead Time) 的時間越短。


## 指標: 平均處理時間

如果比起處理的效能，你更在意處理過程中花費的資源的話，那麼除了 WIP 之外，還有另一個指標可以參考，那就是 "平均處理時間"。

"處理時間" 的定義，就是每個 Task 從 DoStepN(1) 開始的那瞬間，到 DoStepN(3) 結束的那瞬間為止所花費的時間。平均處理時間就是所有 Task(s) 處理時間的平均值。在處理過程中，必定會佔用部分資源 (如 memory 等等), 同樣的資源，被佔用的時間越長，代表你的資源使用越沒效率。



## 觀察執行狀況

<!-- metrics and task state profile -->

講了這麼多指標，不過沒有好的工具搭配的話，你改了一版程式，你能馬上知道結果嗎? 先前在上 Ruddy 老師的課，他不時都提到一句話: "要先能度量，才能改善"。沒錯，沒有明確的指標當作指引的話，你做了任何修正，帶來的改善幅度你只能憑感覺了。因此在準備這個練習題時，我花了一些功夫，來處理這個環節的問題。

我的目標很簡單，上面提到的所有指標 (還有包還一些我自己加上的其他指標)，我都期望在執行的過程中，就像各種維運監控的 dashboard 一樣，如果能隨時讓我知道這些數值的變化狀況就太好了。

另外，我一直提到，每個 developer 應該都要很 "精準" 的掌握自己的 code 到底是怎麼被執行的。唯有這樣你才有能力去調校你的 code 讓他達到最佳狀態。我另一個目的是，如果能用類似 甘特圖 的方式，用視覺化的方式呈現出你的 task 執行的順序的話，那對於理解驗證你的程式執行狀況也會有很大的幫助。

這邊我用了個以前我常用的技巧: 用 csv 的格式，每隔固定時間 (ex: 100 msec), 輸出當下所有指標的數值。整個程式執行過程的 csv 檔案，我就可以直接用 excel 開啟，不需要透過太多監控工具或是涵式庫，我就能輸出漂亮的圖表來評估執行結果了。這個技巧在 POC 階段尤其好用，你不需要相依太多跟主題無關的 package, 也不需要動用太過複雜的技巧，就能達到目的。

因此，這個練習題的套件，都會按照執行的時間為檔名，自動產生執行過程的 .csv 檔。我簡單示範一下怎麼使用 csv:






## 小結: 為何這些指標很重要?


# 答題規範


# 範例講評 (待續) ...



















