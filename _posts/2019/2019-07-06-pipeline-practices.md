---
layout: post
title: "後端工程師必備: "
categories:
tags: ["系列文章", "架構師", "CLI", "C#", "PIPELINE", "串流處理", "TIPS"]
published: true
comments: true
redirect_from:
logo: 
---

延續前兩篇文章，繼續在來聊聊後端工程師的話題吧! 後端工程師免不了必須解決很多效能及穩定度的問題，因此 "精準" 的掌握你程式碼在做啥事，我覺得是很關鍵的一點。商業邏輯我想你寫得出來大概都沒問題，但是每當我講到平行處理 (例如非同步、多執行續、或是 scale out) 等等議題時，我發現能清楚掌握的人就少了一大半了。如果討論我們多執行緒應該怎麼安排這些任務的處理規則，能精準地寫出來的人又少了一大半...。

我在公司負責架構的團隊，其中一個任務就是替其他團隊搞定這些問題，並且包裝成套件讓其他團隊能輕鬆解決這類問題。為了確保 team member 有足夠的能力做好這件事，我就在內部弄了一個練習用的 side project, 讓大家玩看看。我不大想去考演算法 (想練這個的去寫 leetcode 就好)；也不想單純的考你怎麼解決問題 (這個應該考白板題就好)；我也不想考你會不會特定語言或框架 (這個我也不會 XDD)；我想考的是這些能力是否平衡? 畢竟真正上場的時候，我需要 team member 能夠自己決定最合適的做法啊，這樣成員才有可能成長，我也才能輕鬆一點 (咦?

為了做到這件事，我設計了一個 project, 函式庫內我定義了一個類別 MyTask，他的 instance 必須按照順序呼叫 DoStep1(), DoStep2(), DoStep3() 才算完成。你必須處理完 1000 個 MyTask 物件才算完成任務。處理過程中有些限制或是困難需要克服:

1. 每個 Step 的平行處理數量是有上限的，例如任何 Task 之間的 Step1, 同時間最多只能有 3 個執行。
1. 每個 Step 會花一些時間處理 (不是立即 return)
1. Task 從 Step1 開始，到 Step3 結束的過程中, 會 allocate 大量的 memory (預設: 64mb), 你必須盡可能的降低處理到一半的 Task 數量 (WIP: Work In Progress)

題目會用 IEnumerable<MyTask> 的方式交付 1000 個物件，你的目標是寫一個 Runner 接到 Task, 把它消化完畢就對了。不限定你用任何方式或是框架來處理。不過，我會看這幾個指標來判定你做出來的品質:

1. 主要目標: 是否有確實完成每個 Task? Step 1, 2, 3, Total 1000 Task(s)
1. 品質指標: max(WIP)
1. 品質指標: TTFT(time to first task)
1. 品質指標: Finish Time

準備好接受挑戰了嗎? 現在就去下載題目來試著解看看吧! 這篇文章我會分成前後兩段來發布。前半先發布題目，如果你有意願的話，在一個月內 (時間 FB 我會說明)，在 GitHub 把你的 Runner 發 Pull Request 給我, 我會在後半段發布的內放上 PR 給我的 code, 並且評論一下每種解法的優缺點。

<!--more-->

# 寫在前面: 動機

會寫這文章的動機很單純，就是我一直覺的很多後端工程師必備的基本功，在這個框架滿天飛的年代，都被忽略了。很多問題明明只要基本知識足夠，簡單兩下就能搞定，但是越來越多工程師抱著大部頭的框架來解決。解了問題是好事，但是也讓後續的維護門檻變困難，長期下來得不嘗失啊!

這類問題，平常在做 code review 很難深入到這樣的問題啊 (被我 review 的大概整段 code 都得翻掉了)，在動手寫 code 之前就先做好充分練習才是根本之道，因此我就出了這樣的練習題給 team member 試看看，發現效果還不錯，於是就擴大範圍，也讓其他有興趣的朋友們參與看看。

當然我還有另一個動機: 招募。我也希望能藉這機會找到有心想磨練自己基本功的工程師，這樣的 code 交流我相信比面試聊上一個小時精準的多了。最重要的是透過這樣的方式，你會更清楚知道團隊的要求，你也可以藉這機會試試自己能力；加入團隊後會有更多這樣的挑戰與應用的機會。這不見得是件輕鬆的事情，但是如果你有興趣，這絕對是個難得的機會。


# 品質指標的挑選

要通過這個測驗，其實很簡單，寫個 for loop 就搞定了，但是要比較出好壞，那就要花點心思。我這邊說明一下為何我要挑選這幾個指標來評斷 code 的優劣。這些指標，其實都可以對應到各位日常碰到的實際案例，我就一一來說明。

開始之前，先來看一下最陽春的 runner:

```csharp

public class AndrewTaskRunner0 : TaskRunnerBase
{
    public override void Run(IEnumerable<MyTask> tasks)
    {
        foreach (var task in tasks)
        {
            task.DoStepN(1);
            task.DoStepN(2);
            task.DoStepN(3);
        }
    }
}

```

你只要按照順序，把每個 (預設 1000 個) MyTask 的 DoStepN(1) ~ DoStepN(3) 執行過一次，就算完成。

## 指標: 最大半成品數

這裡指的 "半成品" (WIP, Work In Progress) 數, 就是指同一瞬間，有多少 Task 是處於 DoStepN(1) 已經開始，而 DoStepN(3) 還沒完全結束的階段。

為何我會拿 WIP 當作指標? 對應到現實世界的 Task, 通常啟動後就會占用一些資源，從 temp file, memory cahce, memory buffer, 甚至是為了處理任務過程中需要的 temp object 等等都算。如果你用了各種平行處理的技巧來加速，別忘了 WIP 越高，你占用的資源越多，因為這些資源要在 DoStepN(3) 結束後才會被釋放。

WIP 過高，先不論對效能的影響，如果對於關鍵資源 (如 memory) 敏感一點的環境, 也許你的系統撐不過尖峰就會掛掉了。因此這次的題目，會監控 Runner 全程執行過程中，WIP 的最大值，當作 max(WIP) 指標。


## 指標: 第一個任務完成時間

熟悉 SCRUM 的大概都對 WIP 不陌生，這名詞我的卻是從那邊借來用的。另一個 SCRUM 在做任務管理的指標就是 Lead Time (交期, 從需求提供到任務完成交付的時間)。這邊我也拿 Lead Time 當作指標之一。不過我比較偏好 TTFT (Time To First Task completed) 這名詞。這名詞我是從 Browser 的開發工具那邊抄來的。監控網頁下載效率，有個很重要的指標 TTFB (Time To First Byte) 也是一樣的意思。

TTFT 會直接影響使用者的感受，有大量 Task 交付執行時，你能完成第一個的時間，就是使用者視角看到的 Lead Time。過去在念作業系統 (OS, Operation System) 時, 對於多工排程的機制也有類似的指標，那個叫 "平均等待時間"，意思是每個 Task 從被交付到 OS 開始 (這裡指的是 Runner 啟動) 到 Task 完成的時間平均。TTFT 越大，代表你花越多時間在 "等待" 某些階段的完成。

如果你能越早交付第一個 Task, 使用者就會感受到系統的回應速度越快，如果使用者端能配合，或許有後續的任務就能越快啟動。這是我挑選這個指標的用意。







## 指標: 所有任務完成時間

相較於 TTFT 在意第一個 Task 完成的時間，另一個代表整體效能的指標則是整體完成時間，如果你硬要對照的話，可以把它看成 TTLT (Time To Last Task completed) 也行。這指標完全不管過程中你如何交付 Task 的，只看最後一筆的交付時間，這指標代表整體效率。

有些情況下，TTFT / TTLT 哪個重要，其實很難斷定，完全看你對於系統的服務品質怎麼定義。舉例來說，當 Task 的數量很大的時候，你能否忍受一個明明只要一秒鐘就能完成的任務，卻要在 1 小時後才能得到結果，換來的代價可能是整體完成的時間可以加速 30%, 或是執行的成本降低 30% ? 不同的考量，會影響這些指標的重要程度。

我在這個案例，由於我考量的是 pipeline, 越快完成第一個任務，我後續的階段就能越快開始，因此我把 TTFT 的重要性排在前面。




## 指標: 平均完成時間

這是從 OS 排程那邊學來的另一個指標。只看第一個任務，跟只看最後一個任務的完成時間，其實都是兩個極端。老實說我要是知道規則還蠻容易作弊的 XDDD, 假設我整批處理能縮短 30% 的執行時間，那麼為了 KPI 好看，我可以只處理第一筆，然後就交付成績；後面 2 ~ N 筆再用最有效率的做法，再最後才一次交付 2 ~ N 筆 Task 的成果，來衝這兩個 KPI 帳面上的數字...

當然這樣就本末倒置了，使用者體驗一定是不好的啊，因此我追加一個 OS 提到的指標: 平均等待時間。

這指標的定義是:每個 Task 的交期的平均值。這個案例裡，就是每個 Task 從 Runner 啟動開始，到 DoStepN(3) 完成為止的時間總平均。這是介於 TTFT 與 TTLT 中間的指標，越低代表使用者需要等待 (就是 Lead Time) 的時間越短。







## 小結: 為何這些指標很重要?


# 答題規範


# 範例講評 (待續) ...



















