---
layout: post
title: "架構面試題: 平行處理的同步控制技巧"
categories:
- "系列文章: 架構師觀點"
tags: ["async"]
published: false
comments: true
redirect_from:
logo: 
---

網路上一直都有兩派人在爭論這個話題: 到底面試刷題 (leetcode) 重不重要? 有人覺得刷了 100 題，結果實際上陣寫不出東西也是枉然，也有人認為會一堆工具，結果寫出爛 code, 或是時間複雜度糟的很離譜的 code 基本上也寫不出高品質的系統。其實我自己的看法沒那麼兩極，我相信這些基礎功夫的重要性，我自己也是認同平日應該多練習 leetcode 的，但是以面試為目的來快速刷題我就不鼓勵了。刷題是證明你的知識足以回答 leetcode 的考驗，而不是把他當作考古題來應付面試。

另外一個觀點則是，理論基礎固然重要，但是你處理的畢竟是工程問題 (尤其是後端工程師)，你總是要有幾個熟悉的工具來實現你的想法，因此熟悉幾個特定領域的工具或是技巧也是必要的。太過極端都不是好事，例如有人就會說:

> "我給你了把好槌子，可是你為什麼沒變成米開朗基羅?"

另一個極端也不是好事，如果你真的有米開朗基羅的想法，但是不會拿鑿子也是枉然...
























------------

每次都寫那麼長一篇文章其實很累啊，偶爾也寫些小品的好了。這次重回過去的主題: 多執行緒；來談談多執行緒的控制技巧。

之前我寫了一系列的多執行緒處理技巧的文章，同時也在 RUN!PC 的專欄寫了好幾篇。看看也是十年前的文章了啊! 不過，同樣的主題，十年後總是有不同的詮釋方式，這篇我就特別針對兩個部份來探討:

1. 執行緒同步控制
1. 非同步呼叫 (async) 的控制

如果你之前有來聽我 1/23 及 1/28 的分享，我在 Message Queue 基處建設介紹那段就有示範這篇的 sample code 了。對這段有興趣的朋友，可以看那天的錄影 (請參考 00:00 ~ 00:00 的部分)。不過有些東西，用文字表達會比較精確啊，怕被我的聲音催眠的朋友，可以繼續往下看文字版的 XD

<!--more-->

# 什麼是執行緒同步控制?

為什麼要寫這篇，先在這段交代一下好了。這些技巧，在應付 server side (不論是哪一種) 的開發尤其重要。開發在 server side 執行的程式，不外乎都有這幾種基本需求:

1. 長時間執行
1. 高併發, 高效能 (對於提高整體 throughtput, 降低 response time 的要求)
1. 正常的終止執行 (graceful shutdown)

這些要求要做到位，每一件事都要求你對於多執行緒的控制能力必須到位。舉例來說，長時間執行的 code, 某種程度都會有個無窮迴圈類型的 code 在接受來自外界的 request, 不論你的 code 有沒有看到這個 while(true) { ... } loop。基本上所有平行處理的任務，你只要用了 pooling (輪巡, 固定時間去確認狀態, 而非等候通知)，你這段 code 就已經限制住你整體的效能上限了。

舉例來說，就用我這次說明的 Message Queue 來當例子就好了。假設你今天接受訊息的來源不是 Message Queue, 而是 file server, 或是 database 這類被動的 storage, 沒有人幫你把 "收到訊息" 這件事包裝成任何型態的 notification 的話 (例如: RabbitMQ .NET client 提供 event 的方式通知收到 message), 那麼最常看到的解法, 就是:

> 那我每隔 1 sec 去確認一下有沒有新的 message 進來...

這會是個很頭痛的解決方式。我隨便舉幾個情境你就知道頭痛了:

1. 效能天花板:  
如果 1sec check 一次, 那麼這個 worker 的效能極限就被限制在 1 rps 以下了。問題的另一面，你的 worker 平均回應時間至少是 0.5 sec 起跳。

1. 效能天花板改善:  
要改善

1. 輪巡 (pooling) 通常都是 worker 端主動發動, 去拉取 (pull) 訊息回來處理。這時如果沒有同時處理好鎖定問題的話，很容易造成一個 message 被一個以上的 worker 搶走，造成同一個 message 被處理多次的問題。





# WaitHandle

# Async

# References

# 總結
