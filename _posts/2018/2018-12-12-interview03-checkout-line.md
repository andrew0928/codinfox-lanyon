---
layout: post
title: "架構面試題 #3, 線上購物的排隊機制設計"
categories:
- "系列文章: 架構師觀點"
tags: []
published: false
comments: true
redirect_from:
logo: 
---

轉到電商後，經歷過第一次雙十一的洗禮，總算是親身體驗大流量的刺激與震撼了 :D，其中的辛苦我就不多說了，這次都還是仰賴經驗老到的同事們渡過難關的。不過這次我們能安然渡過，先前開發的排隊機制功不可沒。但是這次我們也發現到排隊機制其實還有些優化改善的空間，可以讓排隊中的消費者有更好的體驗。

雙十一過後，我試著在思考如何改善排隊的做法... 不過很少看到有文章在探討這類機制該如何開發? 於是我試著研究這個議題，也簡單的寫了 POC 來驗證想法，就順手寫了這篇...。

這篇跟前一篇 [微服務基礎建設: 斷路器 #1, 服務負載的控制]() 的出發點是一樣的，都是要透過某些程序，限制同時取用服務的請求，確保服務端有足夠的資源來完成任務。只是上一篇控制的是 server 能 "同時" 受理多少 request 的管控機制，控制的是 "速度"。而這篇我要探討的是這些 request 應該要用什麼樣的規則與順序，決定那些 request 可以被服務? 換個角度說，上一篇講的 Rate Limit, 是針對上游服務做管控，而這一篇要講的排隊機制，則是針對直接連線的使用者做管控。

這兩件事情都做到位，你就能掌握好服務對使用者的 QoS (Quality Of Service) 了，這是使用者體驗很關鍵的一環，不過往往 developer 都不會把它擺在第一順位 (一般情況是: 規格就沒這項啊，通常都是上線了有人來抱怨再說...)


<!--more-->



# 問題與需求

開始前我定義一下我講的 "排隊機制" 到底是什麼? 我對這個排隊機制的期待到底有哪些?

首先，我指的 "排隊機制" 是:

> 購物網站在結帳時必須做大量的驗證與計算，為了確保運算能順利進行，同時間只能允許一定個數的使用者進入這個階段。其餘還未能進入結帳的訪客，就必須進入 "排隊" 狀態。若前面的使用者已經結束結帳的程序，空出的資源就可以依序按照順位，讓下一位使用者優先進入結帳。

理想的排隊機制，不只是要保護系統的處理能力不被沖垮而已，同時也應該要顧及排隊者的體驗，例如能隨時得知排隊的順位、預估剩餘時間等等。這些過程中也要確保不要過度耗用系統的資源，最好也能提供足夠的監控資訊確保運作順暢。

這會不會太貪心了一點? 其實不會。按照慣例，既然是 POC，我在意的就是可行性。我先略過花時間的工程問題，把規模先縮小到單機的範圍，也跟外部的各種工具、服務或是框架的相依性降到最低。雖然規模縮小了，不過平行處理這環節可不能省，因此 thread safe / lock 這件事還是得做，我必須確保這設計將來是可以擴大為分散式的版本。

做這次排隊機制的改善，我歸納一下期待改善的幾項 (有些是前一版的缺點，我一起列):

面對使用者端的需求 (frontend developer):
1. 必須是 pooling 模式, 使用者必須不斷的 check status, 也可能會在任意時間中途斷線。
1. 核心引擎設計期望的排隊數量: 10,000 人, 更新週期為 1 sec
1. 排隊的結果必須是公平的 (只要沒有被剔除隊伍，先排的一定要先使用服務)，不允許後來先到的狀況，尤其是資源有限制數量時更應該確實做到。
1. 排隊的過程必須提供明確的 feedback, 必須讓使用者知道目前狀態 (是否能開始進入結帳)，也必須告知順位 (前面還排幾位)。若能搭配平均處理速度的統計數據的話，就能進一步預估等候時間。

面對維運人員端的需求:
1. 必須能排隊的狀態 (排隊中,結帳中,已完成,已放棄...) 的即時數據監控
1. 必須能動態調整排隊的參數 (如排隊上限、允許同時結帳人數等等)
1. 必須有能力手動踢除使用者 (by id, by queue, by idle time ... etc)

核心服務開發人員端的需求:
1. 每個使用者查詢排隊狀況請求時, 要降低 storage 的 IO 數量 (storage IOPS 過高是舊系統的瓶頸, 也直接影響 cost)
1. 每個使用者查詢排隊狀況請求時, 運算的時間複雜度必須是 O(1)
1. 隨時都可能有使用者決定離開或是斷線。必須設計機制排除這些使用者，避免佔用位置又不進行交易
1. 必須能同時提供多個 (100,000) 個獨立的排隊隊伍


對於架構師來說，這是各方提出來的許願池啊，要同時兼顧實在有點困難。不過這就是挑戰，我期望在 POC 階段就盡可能確定核心的設計能滿足這些需求。考量到我自己一人不可能同時熟悉各種開發實做技術

對於開發團隊來說 (要將這 POC 產品化，或是將來要使用我這服務的開發團隊)，這就是最好的 MVP 啊，我可以最快的得到 feedback, 就算失敗了我也能快速確認這條路不可行。很多團隊往往看了一堆理論方法，卻掌握不到 MVP, Fast Fail 等等作法的要領...，實在可惜。面對越複雜、越關鍵或是越核心的問題，越值得多花點心思確認可行性。這個排隊問題我就用這種標準去看待它，這篇就正好記錄整個過程。



# 現實世界的排隊搶購

如果要真的從演算法開始講，那應該會看到睡著... 我先找實際生活中的案例來對比好了。台灣人這麼愛排隊，應該不缺這類經驗吧。當年念書期間受到嚴格的 OOP 訓練洗禮 (老師是 smalltalk 教義派)，很多問題我都習慣先思考一下，沒有電腦的世界是怎麼處理這類問題的? 往往從這些現實世界的解決方式，都可以對應到 code 的處理流程。如果現實世界的店面排序都可以靠工人智慧就能有條理地進行，沒道理線上就不行吧!

所以我想了想，一些熱門的美食小吃，排隊時都怎麼做? 讓排隊機制可以更可靠有效率? 我拿餐廳當作例子:

1. 餐廳內的座位數量有限 (A)，你可以浪費一些座位，讓位子是空的 (排隊管理的效率差的情況)。但是你絕對不能把兩個顧客塞在同一個座位上
1. 點菜跟上菜需要時間，可以讓快要排到的顧客 (B) 先進行這段程序 (ex: 預估 10 min 內會輪到他入座的顧客, 或是排最前面的 10 位)
1. 每日限量，過去估計一天若能服務 300 (C) 位客人，那其實可以直接告訴排在第 500 (D) 順位以後的顧客不用排了，今天應該輪不到他。對這些顧客可以採取其他的服務，例如給優惠券、或是留下電話等等若真的還有位子可以通知他...

單純就 "規則" 而言，我覺得這個方式還蠻有效率的。規則訂好之後，每個顧客，還有店員要執行的動作都很簡單，簡單到不需要太多的訓練或說明，就能有效的運作下去。舉例來說，上述幾個例子，都可以按照顧客排在隊伍內的位置決定。如果排隊時顧客都有領號碼牌，那就更容易了，直接找號碼牌在範圍內的顧客就可以了。


# 排隊機制演算法

看 code 前，先來看看這演算法怎麼運作。若暫時不考慮斷線的使用者狀況，還可以更精簡一點。每一組獨立的排隊 (例如一家餐廳)，只須要維護這些資料就可以運作:

每組隊伍:
- 結帳起點 (integer)
- 排隊起點 (integer)
- 排隊終點 (integer)
- 號碼牌發放 (integer)

正常的情況下，其實只要這四個整數，加上每個使用者手上的號碼牌，排隊機制就能順利運作了。不過過程中總是有些意外狀況發生，例如有人離開排隊隊伍，但是你不知道他還會不會回來，因此要記錄他最後一次回報的時間，才能判定他已經離開多久，是否要把他剔除。如果這個人已經確定離開隊伍，則這筆資料就可以刪除。整個隊伍維護的資料範圍是有限的，token 範圍最多從 "結帳起點" 到 "號碼牌發放" 之間的 token 才有可能有使用者資訊。

接下來先看看這機制怎麼運作吧，來看一下連續動作:

## 開店 (初始狀態)

![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-03.png)

對應到前面餐廳的例子，如果店內只有 7 個座位，隊伍長度最多只設定為 15，超過就直接請他不用排隊了的話，那麼初始直應該如圖所示:

用餐中(可進行結帳程序): 1 ~ 7
排隊中: 8 ~ 21
號碼機: 1 (下一位加入隊伍的人，會拿到 1 號)


## 開始營業 (使用者湧入)

![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-04.png)

如果開張之後，有第一位使用者進來了，那麼...

1. 使用者先取號碼牌 (token), 由於 [號碼機] 數值為 1, 因此他可以取走 token(1) 這張號碼牌，並且加入隊伍。號碼機被抽走 token(1), 下一位取票的會拿到 2
1. 由於這位使用者的 token(1) 數值是 1 號，照隊伍的狀態來看，只要在 [排隊起點] 數字之前的使用者都可以直接進入用餐。因此這使用者直接可以進入用餐狀態 (紅色)。



![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-05.png)

接著，又一位使用者來排隊，重複上述動作，結果如圖所示



![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-06.png)

再來，陸陸續續又來了 7 位，重複上述動作，結果應該如上圖所示。

這時，拿到 token(8), token(9) 兩張號碼牌的使用者，因為他的數字比 [排隊起點] 大，因此必須在櫃檯那邊開始排隊了 (藍色)。

因為 [排隊起點] 的數值是 (7), 這時 token(8) 使用者可以透過 8 - 7 = 1 知道他自己是第一順位。同理 token(9) 也可以不用店員告知，就知道他是 9 - 7 = 2 第二順位。


## 營業中 (使用者結帳)

![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-07.png)

使用者進去店內用餐後，token(3) 使用者吃得比較快，決定先結帳離開，於是就起身到櫃檯去結帳了 (粉紅色)。



![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-08.png)

結帳過程需要一些時間，從使用者起身去櫃檯付款，直到處理完畢後這個位子才能空出來繼續服務為止。這過程結束後，還在排隊的使用者就可以進來店內用餐了。因此座位清理好這瞬間，整個隊伍的狀態應該變成上圖所示。紅色空心的數字代表這位使用者已經離開，但是系統的排隊資訊理還認得這個 token (因為 token 還在隊伍範圍內)，因此圖案用紅色空心，但是邊框是實線的方式表達。

這瞬間，因為空出 (3) 的原因，[排隊起點] 與 [排隊終點] 都往後移了一位。這時 token(8) 使用者正好是第一順位，他的狀態自然也從排隊中(藍色)，改為可進入用餐(紅色)。這時 token(9) 還沒辦法進入用餐，必須繼續排隊 (因為 9 > 8)。這時 token(9) 的順位是 1 ( 9 - 8 = 1 )。


![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-09.png)

此時，如果又有一位使用者 token(2) 用餐完畢，重複上述的步驟，結果如上圖所示。這時 token(9) 也可以進入用餐了。[排隊起點] 及 [排隊終點] 的指標再次右移一位。

## 營業中 (清除隊伍不必要的資訊)

![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-10.png)

不知各位有無留意到，即使陸續有人排隊，也有人結帳離開，但是隊伍資訊的 [結帳起點] 卻一直沒有變化，因為開店後第一位進入用餐的 token(1) 其實都還沒離開，因此 [結帳起點] 都還維持為 0。簡單的紀錄，方便店家知道，如果他要查閱目前所有隊伍的資訊，只要從 [結帳起點]: 0 開始往後找就好。

如果這時， token(1) 也要結帳離開了的話... 結果會變成下圖:

![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-11.png)

整個的結帳處理程序，都跟前面一樣。唯獨不同的是，隊伍最前面 1, 2, 3 都已經結完帳走人了，有連續的一塊區塊都已完成結帳，這時 [結帳起點] 還從 0 開始紀錄已經沒有意義了，下次要維護隊伍資料，或有任何目的要掃描一次所有隊伍資訊時，不再需要從 0 開始，下次直接從 3 開始即可，因此若偵測到原本的 [結帳起點] 後的使用者已經離開，這個指標就能夠往右移動，直到一到下一個還沒離開隊伍的使用者為止。以這個情境為例，新的 [結帳起點] 應該是 3 才對，請參考上圖所示。


## 營業中 (使用者體驗，預測等待時間)

排隊使用者的心理就是一直在想:

> 到底還要等多久? 會不會等到我就賣光了?

隨著排隊隊伍越來越長，這類資訊的需求及更新頻率會越來越高，因此排隊機制最好在設計之初就考慮好這個問題。處理得當可以避免很多後端不必要的運算。延續這個案例，繼續看一下，如果排隊隊伍越來越長，[號碼牌] 領到 18 的狀況:

![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-12.png)

如同前面說過，如果最後一位排隊的使用者 token(18) 想知道他的順位，馬上就可以得知 18 - 10 = 8。這個數字完全不需要做任何的搜尋就可以得知，時間複雜度只有 O(1)。

為何我會不斷的強調這件事? 以這個案例，走到現在的狀態是:

排隊中的使用者共有 8 位 (11 ~ 18), 如果每位每一秒都要看一次他還要排多久, 則這個動作 server 每秒會被問的次數:

RPS = 8 / 1 sec;

如果排隊中的使用者有 N 位，那 RPS 就是 N 了。人數變多，或是查詢頻率提高，都會讓這個查詢的 RPS 拉高。先前我提到舊系統的案例，這邊就是個大瓶頸。當時這部分的開發不完全是為了這個情境設計的，有別的考量，這部分一個使用者查詢執行的時間複雜度是 O(n), 因此整個系統跑下來就變成 O(n^2) 了，然而這個動作，背後還卡到別的雲端服務有 IPOS 的限制 (換句話說就是照 IPOS 收錢的...)，整個成本跟效能就大爆炸啊啊啊...

回到主題，如果能用很低的運算成本跟運算資源，就能讓使用者取得排隊順位的資訊，那麼即使是用 pooling 的做法，我也能適當的提高 pooling 的頻率，讓使用者得到更精準的 feedback。如果你的服務做得更到位一點，額外多花了點精神去統計過去一段時間的消費速度，那就可以更貼心地替使用者預估他還要等待的時間。排除額外統計花費的時間 (那個 server 統一做一次就夠了)，對於每個使用者來說，只是排隊順位 x 平均時間而已，複雜度仍然是 O(1)。

## 存貨不足 (使用者體驗，提早告知使用者不用排隊了)

![](/wp-content/images/2018-12-12-interview03-checkout-line/SOLID-13.png)

接下來看個極端的狀況，你的店生意實在太好，排隊排到下條街去了。排隊人數遠遠超過你能服務的數量。雖然有些人可能會中途放棄排隊會空出一些位置出來；不過按照經驗，總是可以抓個候補的範圍出來，超過這個範圍，不用等到賣光，就可以直接告訴使用者這個結果了。節省使用者端的時間與資源，你自己 server 的附載也可以降低。

面對這個狀況，同樣的拿 [號碼牌] 跟 [排隊終點] 來比較就可以了，只要你手上的號碼牌在排隊終點之前，就有排隊的機會。不過這個判定，不需要先給你拿號碼牌後再判定，[號碼機] 聰明一點的話，這種情況根本就不要吐新的號碼牌給你了。因此發號碼牌的機制，可以先判定 [號碼機] > [排隊終點] 的狀況下，就拒絕使用者領票排隊。

## 小結

軟體開發到最後，越來越覺得正確的架構跟做法還是最重要的，這些搞清楚後，再去找適合的工具或是框架來使用，才會事半功倍。因此我都會強迫自己先撇開這些外圍的干擾，搞清楚問題核心後再來寫 code ..

這段我就是在做這件事。太多個技術雜訊，反而會干擾我的思路。寫到這邊，如果各位讀者還沒完全想通，那可以多花點心思想一下，別急著往下看。這些東西掌握的到位了，才是能受用十幾年的知識。

接下來我的目的，是實作 prototype，目的很簡單，我要交付具體的 "東西" 給我的客戶 (開發團隊)。確保我規畫出來的東西是他們期望的，能解決它們面臨的問題。在這前提之下，我要採用的各種技術相依性越少越好，code 越少越好，理想的情況是單獨一個 C# console application, 幾百行以內就能跑的狀態是最讚的。

這段如果都想通了，就繼續看下去吧!


