---
layout: post
title: "架構面試題 #3, 執行速率控制"
categories:
- "系列文章: .NET + Windows Container, 微服務架構設計"
- "系列文章: 架構師觀點"
tags: ["架構師", "面試經驗", "microservices"]
published: false
comments: true
redirect_from:
logo: 
---

面試題這系列來到第三篇，這次換一個應用題，來考考比較屬於 operation 層面的應用: 流量 (或是呼叫次數) 的管控。

簡單的說，這問題翻成白話就是: "某 API 一分鐘可以呼叫 60 次" 的功能該如何設計，如此而已。別小看這類問題，看似簡單，實作上要解決的障礙還不少。面試階段我會問這問題，自然不是要你馬上寫出 production code 給我看，重點是要看看你思考問題的方向有沒有概念? 有沒有善用抽象化思考的技巧，排除困難的實作部分，思考關鍵複雜的核心問題?

核心問題分兩部分: 

1. 如何定義 "流量"?
  如何得知目前的 "流量" 是多少? 這部分考驗的是定義問題的能力。通常這類問題需求單位很難定義的很精準，因此都要仰賴技術單位來支援。這考驗寫技術規格以及演算法等等基本技巧的考驗；
1. 流量超過預期上限之後的處理方式?
  超過流量上限之後，是延遲這個 task, 直到流量低於限制再執行? 還是直接回覆 error ? 延遲過久可能會造成連線數量暴增，阻斷了其它正常的流量.. 引發額外的問題；回應 error 則間接的把問題交由 client side 處理，也會增加 API 與整體系統的複雜度。
  這邊會用到多執行緒控制，非同步的控制等等相關技巧。

<!--more-->


# 前言: 微服務架構常用的斷路器

這系列文章，我是定位在 "建構微服務開發團隊" 這前題而準備的面試題目。目的是找出能夠思考及解決問題的人，我期望團隊裡的人解決問題時，第一時間是思考問題的核心是什麼? 接著才是思考有哪些現成的 framework / service 可以用? 或是必須要自己開發? 沒有這層抽象化思考能力的人，往往第一時間就會跳到他熟悉的 framework / service 身上去了，錯過了其它可能更合適的可能性。現成的方案不見得不好，但是通常整合程度會差一些，你也有可能為了殺一隻雞去買整套牛刀回來...。這種狀況在一般軟體開發其實還好 (都很成熟了)，但是在微服務開發的領域上，這問題就被放大了。因為微服務還是個發展中的架構，很多狀況下不會有標準作法...。

流量管控，背後的意義就是對於服務的 loading 控制，以及超過上限的處理。會需要這機制，通常都是為了避免系統內某些資源使用過度，造成整體效能瓶頸，甚至造成雪崩效應...。因此針對這些資源，有時候我們會希望這部分的程式別跑那麼快。例如 Disk I/O, 或是 Network I/O, 或是某些 CPU Bound 的任務，用過頭可能會讓其他程式跑不下去，就有機會運用到這技巧。

其實微服務架構常常談到的 "斷路器" (circuit breaker) 要解決的問題也很類似，某些資源使用過度，無法在提供正常水準的服務時，我們也會對資源的使用開始做些限制，更嚴重時會直接切斷該資源的使用，以確保整個系統還能維持運作。斷路器的作用就像保險絲一樣，隔離附載過度的模組，保護整個系統。在你急著找各種微服務框架的斷路器 framework 之前，先好好了解一下這問題的本質吧! 這樣的好處是，即使你是使用現成的 framework, 你也能適度的抽象化 (訂定內部的 interface), 即使需要更換底層的框架或是服務，也能盡可能的降低影響。


# 限流機制定義 (規範)

這邊我們就用基本的條件就夠了。例如前面的例子: "每分鐘最多只能執行 60 次" 來當作使用案例，各位可以思考一下下列情境:

1. [ ] 控制每分鐘 (整點) 內執行的總數: 在程式一開始的那瞬間，我可以執行 60 次，之後就無法再執行，直到第 61 秒為止。
1. [ ] 控制任 60 sec 區間內的執行總數: 只要執行的那瞬間，往前 60 sec 內的執行總數不超過 60 次，就可以執行。
1. [ ] 控制平均速度 (每秒內最多一次): 每分鐘 60 次，解讀為平均每秒鐘可以執行一次。一開始的一瞬間只能執行一次，直到這一秒過了之後可以再執行一次。

各位看了有沒有霧颯颯? 每一種看起來都 "合理"，那麼我到底要挑選哪一種規則? 老實說這沒有標準答案，我只好按照我自己認為最合理的方式來處理。(1) 用整點的方式，實在太 LOW，完全只是 developer 好實作的考量而以，我直接剔除不考慮。

我以過去 co-location 的經驗當作例子，ISP 給我的限制是採取 (2) + (3) 的做法。例如我買了 10Mbps 的頻寬，但是 ISP 允許我瞬間 (1 min 內) 達到 50Mbps ... 只要我別一直維持 50Mbps, 長時間 (10 min) 的平均落在 10Mbps 以下就過關。

換成限速的規範，就是以 (2) 為基底 (10 min 內最多 10 x 60 x 10 = 6000Mbits 的傳輸量)，但是為了避免瞬間爆量影響其他客戶 (即使後面 59.9 sec 都沒有流量)，他也用了 (3) 作第二層限制 (1 min 內最多 50 x 60 x 1 = 3000Mbits)。只要瞬間不超過 (3) 的限制，長期不超過 (2) 的限制，就可以放行。
 

# 限流機制要求 (介面)

前面把規矩講清楚了，接下來就要定義 interface (考題) 了。你要用什麼型態來呈現這個功能? 我設計了一個 ThrottleBase 的 abstract class, 它提供了 Hit(), 代表你要執行一次指令。如果這個 Throttle Engine 按照上述規則，判定你已經 "超速" 了，就會 block 你的程式，停止一段時間，速度掉到限制以下才會放行。

另外，為了方便統計，同時也應該讓使用端能知道目前速度 (就像你開車上高速公路，你也要知道目前速度離速限還有多少一樣的道理)，ThrottleEngine 也要隨時能回報截至目前為止的速度。

```csharp
    public abstract class ThrottleControlBase
    {
        private int MaxRPS = 10;

        private AutoResetEvent _wait = new AutoResetEvent(false);


        /// <summary>
        /// Increment Counter. if reach MaxRPS, this call will be blocked until the RPS was released.
        /// You can specified timeout to wait until release, if timeout, will return -1.
        /// </summary>
        /// <param name="timeout">give TimeSpan.Zero means wait forever.</param>
        /// <returns>-1 means timeout and do not get lock</returns>
        public abstract int Hit(int millisecondsTimeout);
        //{
        //    if (this._wait.WaitOne(millisecondsTimeout) == true)
        //    {
        //        // enter
        //        return 1;
        //    }
        //    return 0;
        //}

        public async Task<int> HitAsync()
        {
            return -1;
        }


        public abstract int CurrentRPS { get; }


        public WaitHandle GetWorkWait()
        {
            return this._wait;
        }
    }

```

講到這裡，題目定義都清楚了嗎? 準備好回答面試官你要怎麼解決這個問題了嗎?

老實說，我面試工程師這麼多年，我還沒機會搬出這種難度的題目出來... 哈哈, 這篇完全是我自己想寫而已 XD, 如果你有機會碰到很強的 developer, 連這題都搞的定的，記得留話給我崇拜一下。

因為難度有點高，因此我才安排在第三篇。原因有兩個，一來微服務的的場景需要考慮到這個層面才行；另一個原因是核心的原理 (測量速度)，其實就是上一篇 []() 講的連續資料統計的技巧啊...

只是應用的方式有些微的不同，程式碼也可以稍做調整與簡化。細節我就跳過了，有興趣的朋友們可以搭配上一篇一起看。

# 解法 1, 暴力法, 直接查詢資料庫的原始資料


# 解法 2, 單機版, 直接在記憶體內統計


# 解法 3, 分散式, 控制整體服務的流量









### 微積分
### CPU usage 畫出正旋波